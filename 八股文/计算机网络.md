1. TCP三次握手？

    ![alt text](image.png)

    > 三次握手确保通信双方都能确认彼此的收发能力

2. TCP四次挥手？       

    ![alt text](image-1.png)

    ![alt text](image-2.png)
    
    >因为TCP 必须分成 确认对方已经知道你要关闭，以及 对方自己也准备关闭 这两个独立动作，导致需要 四次。

    **2.1** 请简述 TCP 协议中 TIME_WAIT 状态的作用和产生原因。
    - 产生原因：在 TCP 连接关闭的过程中，当主动关闭方收到被动关闭方的 FIN 包并发送 ACK 确认包后，主动关闭方不会直接进入 CLOSED 状态，而是会进入 TIME_WAIT 状态，并等待2MSL时间后再关闭。
    - 作用：**确保最后一个ACK包能被被动关闭方收到**。如果被动关闭方没有收到这个ACK包，它会重发 FIN 包，主动关闭方在 TIME_WAIT 状态下可以重新发送 ACK 包，确保连接的正确关闭。**避免新旧连接混淆**，网络中可能存在延迟的数据包，这些**延迟的数据包可能会在新的 TCP 连接建立后到达**。TIME_WAIT 状态会持续 2 倍的最大段生命周期（MSL），**在这段时间内，旧连接的延迟数据包会逐渐消失**。这样，当新的 TCP 连接建立时，就不会受到旧连接延迟数据包的干扰，保证了新连接的数据传输不受旧连接残留数据的影响。

3. TCP和UDP区别？
    - 连接性(三次握手):面向连接 vs 无连接
    - 可靠性(重传，ack确认，seq保证数据不乱序)
        - TCP将数据分成多个段（Segment），并有自己的seq
    - 数据传输方式：面向字节流 vs 面向报文
    - 数据流控制(flow control，congestion control)
    - 开销(建立连接，重传等网络和资源开销)
    - 使用场景
    
    **3.1** TCP如何保证可靠传输：
        
    - 三次握手
    - seq number分段segment
    - 重传
    - checksum
    - flow control避免丢包
    - congestion control避免丢包

    **3.2** TCP拥塞控制是怎么样的？
    > 最好还是可以用cubic回答
    - 慢启动
    - 拥塞避免
    - 快速重传
    - 快速回复
    - 超时重传
    - 自适应调整

    **3.3** TCP粘包和拆包，以及定长协议，分隔符协议和消息头+消息体协议？
    - 粘包：接收端将多个segement组合成一个包
    - 拆包：若超出MSS，发送方将一个长的package拆成多个小包
    - 定长协议，分隔符协议和消息头+消息体协议：

        ![alt text](image-8.png)

    **3.4** UDP如何实现可靠传输？
    - UDP（用户数据报协议）本身是一个无连接的协议，不提供可靠传输功能。
    - 但可以通过应用层去实现给每个数据记录序列号，超时重传，通过校验和检测丢包等。


4. http和https的区别？
    - 加密
    - 端口
    - 速度/性能
    - 证书

    **4.1**：http是什么？
    
    - HTTP（超文本传输协议，Hypertext Transfer Protocol）是一种用于在客户端（通常是浏览器）和服务器之间传输超文本数据的应用层协议。它是Web的基础，允许用户通过互联网访问和交换信息。
    - **请求-响应模型**：客户端发送一个HTTP请求，服务器接收并处理请求后返回一个HTTP响应。
    - **无状态性**：每个请求都是独立的，服务器不保留之前请求的状态，虽然可以通过其他手段（如Cookies、会话等）来实现状态管理。
    - **灵活性**: 支持多种数据格式，如HTML、XML、JSON、图像等。
    - **可扩展性**：允许开发者定义新的方法和头部字段。
    - 回答：首先H TT是客户端和服务器之间传输超文本的数据的协议，然后他们的传输的模式是请求加响应的这种模式通常是客户端会发送一个PPP请求，然后服务器会去处理这个请求并返返回一个HD响应那么HD，它有很多种方法，包括gate post pot mate等等这些还有patch的呢那但是通常HTC他请求每一个是无状态的每一个请求都是独立的，所以说客户端这边并不会去保存HDTV请求，他的前一个状态通常都是为辅助三省和cocky去保存，那么除此之外呢H TT他支持多种数据类型，包括图片Jason HTML等等，所以它的一个数据传数据可支持类型也非常多样，那他和PPS的区别呢，就是H T他是域名传输的，相当于完全不加密H TPS，他是基于TS和SSL进行加密，通过第二次建立出握手去交换和绘画密钥，那么除此之外呢他们的传输方式也不一样，传输的端口也不一样，是基于80 TPS是基于43端口就是速度方面，HP会更快一点，因为HPV他不需要于要进行加密，除此之外TT在费用上也会稍微节约一点，因为他不需要去建立更多的链接速度上也会更快



    **4.2** https加密过程？

    ![alt text](image-3.png)

        > HTTPS采用了对称加密和非对称加密相结合的方式。在建立连接阶段，使用非对称加密（如RSA）来安全地交换会话密钥；在数据传输阶段，使用对称加密（如AES）来加密实际传输的数据。

    **4.3** 对称加密和非对称加密的区别？

    ![alt text](image-4.png)

    **4.4** HTTP状态码：
    - 1xx：信息性状态码
    - 2xx：成功状态码
    - 3xx：重定向状态码
    - 4xx：客户端错误状态码
    - 5xx：服务器错误状态码

    **4.5** HTTP请求通常有什么组成部分:

    ![alt text](image-5.png)

    **4.6** Get和Post的区别？

    - 参数传递方式(Get通常请求参数会附加在URL后面)
    - 安全性(直接放在URL后面，不太安全)
    - 缓存(get会被缓存，post通常不会)
    - 幂等性(get幂等，post不是)

    **4.7** 简述websocket的原理和应用场景？
    - 定义：WebSocket 是一种 **全双工通信协议**，在一个单一的 TCP 连接上，允许 **客户端和服务器双向实时通信**。
    - 和传统http的区别：传统 HTTP 是“请求-响应”模式，客户端必须发起请求；WebSocket 一旦建立连接，**双方都可以主动发送消息**。
    - 工作原理：浏览器先发一个 HTTP 请求（带 **Upgrade: websocket 头**），请求升级协议；服务器同意后，**连接从 HTTP 切换为 WebSocket**。
    - 建立后：双方通过这个 TCP 连接，随时可以互相发送数据帧，传输的数据可以是文本或二进制。
    - 使用场景：在线聊天系统(QQ，微信) ，在线游戏：玩家位置、血量、动作等要实时同步 → WebSocket 保证毫秒级更新。股票行情/直播弹幕：服务器需要实时推送数据给客户端，而不是等客户端轮询请求。
    - 回答：websocket是基于tcp的全双工通信协议，核心是解决了传统http的请求-响应的单向通信和服务器无法主动推数据痛点，他是工作原理是通过一次http握手去升级协议，通常会带三个核心字段，upgrade：websocket，connection：upgrade，生成一个随机字符串，然后服务端解析并同意后返回101状态码表示协议正式切换，后续双方就脱离http协议而是基于tcp传输websocekt格式数据，通常是二进制（图片，视频）或者文本（json，字符串）的数据格式，并且体积小（仅含少量头部信息）、解析快，并且有长连接的特性。使用场景包括web实时通信比如在线客服，实时数据推送包括股票行情屏，在线游戏中玩家的位置，生命等。
  
    **WebSocket心跳检测和断线重连机制的实现**:
    - 心跳检测机制：**定期(例如设定每30秒)向服务器发送一个小数据包**（心跳包），以此来确认客户端和服务器之间的连接是否正常。
    - 断线重连机制：在**连接异常关闭或检测到心跳超时时**，尝试重新建立连接。
    - 边缘情况：网络抖动，服务器负载过高，防火墙和代理，服务器维护。
    - 回答：websocket是一个长连接的协议，通常双方没有主动关闭连接是会一直维持连接状态。但可能会因为网络波动或服务器负载等导致假死或连接断开，此时websocket会有心跳机制和重传机制保证联通稳定性，心跳机制通常会每隔一个特定的时间，比如5秒客户端会发送一个小的心跳包（简单的json或自定义二机制），服务器如果有响应则会回复一个简单的ack包，就表明这个连接正常，那如果服务端这边有没有没有响应，websocket会有超时重连机制，但是要考虑一些边缘情况，比如遇到网络抖动导致心跳包丢失，或者服务器负载过大主动丢弃心跳包，所以需要设定一个合理的心跳间隔时间和超时时间，以及最大重连次数。

        ![alt text](image-62.png)

    **4.8** http 2和http 3的新特性？
    - **二进制分帧：** HTTP 2.0将所有传输的信息分割为更小的消息和帧，并采用**二进制格式对它们进行编码**，每个帧都有特定的类型和标识。在HTTP 1.x中，数据**以纯文本的形式传输**。
    - **多路复用**：这是HTTP 2.0的核心特性之一。在HTTP 1.x中，**每个请求都需要建立一个单独的TCP连接**，这会导致连接的开销较大，尤其是在高并发的情况下。而**HTTP 2.0允许在一个TCP连接上同时进行多个请求和响应的传输**，不同的请求和响应可以交错进行，互不干扰。
    - **头部压缩：** HTTP请求和响应的头部通常包含了大量的元数据，如Cookie、User - Agent等。在HTTP 1.x中，**每次请求都会重复发送这些头部信息**，造成了大量的带宽浪费。HTTP 2.0采用了**HPACK算法对头部进行压缩**。该算法会在客户端和服务器端维护一个头部字段表，对于重**复出现的头部字段，只需要发送一个索引值**。
    - **服务器推送**：在传统的HTTP 1.x中，客户端需要**明确请求每个资源，服务器才会返回相应的数据**。HTTP 2.0中，服务器可以根据客户端的请求，**预测客户端可能需要的其他资源**，并主动将这些资源推送到客户端。例如，当客户端请求一个HTML页面时，服务器可以同时推送该页面引用的CSS文件和JavaScript文件。
    - http3：基于 **QUIC 协议**，QUIC 协议在 UDP 之上构建，解决了 TCP 层的队头阻塞问题，即使某个数据包丢失，也不会影响其他流的传输。
    
    - 回答： 相对http1，http2和http3做了很多的升级，http2做了相关的升级包括支持二进制编码，相对http1是直接以文本格式进行传输，容易解析出错和效率低，http2将所有传输数据（请求头、请求体、响应头、响应体）拆分为“二进制帧”（Frame）。这样优势：机器解析速度快，错误率更低，并且为多路复用打下了基础。Http2还支持多路复用，相当于http1单个TCP连接中，同一时间只能处理1个请求，HTTP/2 将每个 HTTP 请求 / 响应封装为一个 流（Stream），并分配唯一Stream ID，每个流的内容拆分为多个 “二进制帧”，所有帧在同一 TCP 连接中并发传输，接收方通过Stream ID将帧重组为完整的请求 / 响应，彻底解决队头阻塞，1个TCP连接即可承载域名下所有请求，减少TCP握手耗时和服务器连接压力。同时，Http2还支持头部压缩，通过HPACK算法将大量常见的重复头部信息压缩成一个索引值，头部体积可压缩至原来的1/10甚至更小，尤其对移动端弱网环境，带宽节省效果显著。最后，http2还支持服务器主动推送数据，比如用户在请求访问一个网页时，http1需要去做多轮请求才能拿到完整的数据，但是http2中服务器可主动推送“与主资源关联的资源”（如客户端请求index.html时，服务器主动推送style.css和app.js），无需客户端额外请求；那么http3在http2基础上，底层传输协议从TCP改为QUIC。

    
    **4.9** http缓存的理解？
    - **强缓存：**
        - 浏览器直接从本地缓存中读取资源，无需向服务器发送请求。通过响应头中的 Expires 和 Cache-Control 字段来控制。
        - Expires：它的值是一个**具体的时间点**，表示资源的过期时间。当再次请求该资源时，若当前时间**未超过 Expires**指定的时间，则使用**本地缓存**。
        - Cache-Control：常见的值有 **max-age**（指定资源在多少秒内有效）、**no-cache**（表示需要先与服务器验证资源是否有更新，再决定是否使用缓存）、**no-store**（表示不使用任何缓存）等。

            ![alt text](image-52.png)

    - **协商缓存:**
        - 当强缓存失效时，浏览器会向服务器发送请求，验证资源是否有更新。通过响应头中的 ETag 和 Last-Modified 字段来控制。
        - Last-Modified:浏览器再次请求该资源时，会在请求头中添加 **If-Modified-Since 字段，值为上次响应头中的 Last-Modified 值**。服务器收到请求后，会比较资源的当前最后修改时间和 If-Modified-Since 的值，**若相同则返回 304 状态码，否则返回 200 状态码和新的资源**。
        - ETag:是资源的唯一标识符，通常是根据**资源内容生成的哈希值**。浏览器再次请求该资源时，会在请求头中添加 If-None-Match 字段，值为**上次响应头中的 ETag 值**。服务器收到请求后，会比较资源的当前 ETag 值和 If-None-Match 的值，**若相同则返回 304 状态码，否则返回 200 状态码和新的资源。**ETag 比 Last-Modified 更精确，因为即使资源的最后修改时间未变，但内容可能已经改变。

        ![alt text](image-40.png)

        ![alt text](image-41.png)

        - 回答：首先 HTTP 缓存它分为两种分别是强缓存和协商缓存，强缓存分别Cache-Control和expires值，那通常你在像服务器请求一个资源的时候，http响应它会带上这个 Cache-Control 和这个 expires值。关于Cache-Control通常看这几个值，比如 no cache，no store, private等，no store就说明它这个资源不允许被缓存，no-cache表示需要先与服务器验证资源是否有更新，再决定是否用缓存。还有就是 private和public，private就是说这个资源是你的这个特定的资源，仅允许客户端浏览器去缓存，而不允许一些CDN，网关等中间代理进行缓存。那这个Cache-Control还有一个值叫 Max age。就意思是这个资源最大的有效时间，同样表示有效时间还有一个值叫expires，它也是一个显示的时间日期，若两者同时存在，直接忽略 Expires，仅以 max-age 为准。那再到就是这个协商缓存，就当强缓存这边过期了，那此时这个客户端就会协商去向服务器查询这个资源是否会过期，那通常会有两个参数，一个是Last-modified，另一个是Etag，lastmodified是上次更改的日期，etag是基于资源生成的唯一的哈希值，能识别 “内容修改但 Last-Modified 未变” 的场景，所以会比lastmodifed更精准。当客户端如果同时携带If-Modified-Since和If-None-Match，服务器会优先验证 ETag，仅当 ETag 一致时，才会验证 Last-Modified。那服务器就换验证etag和lastmodifed是否和当前资源一致，若一致就返回304状态码并且只有响应头，若不一致就返回200状态码和新的资源。
        

    **4.10** 请列举HTTP头部字段并说明其作用
    - 请求头部字段
        - user agent:客户端的**浏览器的名称、版本号、操作系统等信息**, 服务器可以根据这些信息为不同的客户端提供不同的页面内容或服务,比如针对移动浏览器和桌面浏览器返回不同布局的网页。

            ![alt text](image-54.png)

        - Accept：告知服务器**客户端能够接受的响应内容类型**比如：Accept: text/html,application/xhtml+xml 表示客户端可以接受HTML和XHTML格式的响应。
            - Accept-language：表明**客户端期望的语言**，服务器可以根据这个字段返回对应语言的页面。如 Accept - Language: zh - CN,zh;q = 0.9 表示客户端优先接受中文（中国大陆）的内容。
            - Accept-encoding：作用：告诉服务器**客户端支持的内容编码方式，常见的有 gzip、deflate 等**。服务器可以根据这个字段对响应内容进行压缩，以减少数据传输量，提高传输效率。
        - cookie: 用于在 **客户端和服务器之间传递会话信息。** 服务器通过 Set - Cookie 响应头将一些数据发送给客户端，客户端在后续的请求中会通过 Cookie 头部将这些数据再发送回服务器，从而实现会话跟踪等功能。

            ![alt text](image-53.png)

        - Authorization：用于向服务器**提供用户的身份验证信息**，常见的认证方式有基本认证（Basic）和令牌认证（Bearer）等。例如，Authorization: Basic base64(username:password) 用于基本认证。

    - 响应头部字段
        - Content-Type：指示响应内容的MIME类型，**告诉客户端如何解析响应数据**。例如，Content - Type: text/html; charset=UTF - 8 表示响应内容是HTML格式，并且使用UTF - 8字符编码。
        - Content-Length：指定响应**内容的字节长度**。客户端可以根据这个字段来判断响应数据是否接收完整。
        - Set-Cookie：服务器使用该字段向客户端**发送Cookie信息**，**客户端会将这些Cookie保存起来**，并在后续的请求中携带。可以设置Cookie的名称、值、过期时间、路径等属性。
        - Location：在**HTTP重定向时使用**，用于指定**重定向的目标URL**。当服务器返回3xx状态码时，会通过 Location 字段告诉客户端应该访问的新地址。
        - Cache-Control：用于**控制缓存策略**，指定**响应内容是否可以被缓存**，以及**缓存的时间等**。例如，Cache - Control: max - age = 3600 表示响应内容可以被缓存1小时。
        - ETag：是一个**资源的唯一标识符**，服务器为**每个资源生成一个ETag值**。客户端在后续请求时可以通过 If - None - Match 头部携带之前获取的ETag值，服务器会比较这个值，如果资源没有变化，就返回304状态码，告诉客户端使用本地缓存。

            ![alt text](image-57.png)

            ![alt text](image-58.png)

            ![alt text](image-59.png)

        - 通用头部字段：
            - date：表示**HTTP消息生成的日期和时间**，格式为 RFC 1123 标准。可以用于调试、缓存验证等。
            - connection：控制**客户端和服务器之间的连接方式**，常见的值有 keep - alive 和 close。keep - alive 表示在一次请求完成后保持连接，以便后续请求可以复用该连接；close 表示请求完成后关闭连接。
            - server：**标识处理请求的服务器软件名称和版本号**，例如 Server: Apache/2.4.41 (Ubuntu)。

                ![alt text](image-60.png)

                ![alt text](image-61.png)
        - 回答：那通常 HTTP 它分为HTTP请求和HTTP响应，分别附带的字段都不一样。那我就先说 HTTP 响应，它常见的一些头部字段有比如content type，它会告诉你这个响应内容它是什么一个类型，它可能是一个比如说text/html，那么他就会告诉你要解码的方式比如utf-8。那还有就是像 content length，它会告诉你响应体的字节长度，确保客户端客户端通过该字段判断响应体是否接收完整。那么再就是还有 set cookie，服务器向客户端 “设置 Cookie”值，包括session ID，Secure，Path（Cookie 生效路径）等。那么。再就是像之前提到的 CACHE-control 还有 expires，它会告诉你就是这个资源类型它的一个缓存的机制和缓存的显示过期时间等等。那么再就是HTTP请求的常见的头部字段，比如user agent，那 user agent 它就会显示告知服务器客户端的 “浏览器类型、操作系统、设备型号”，那通常服务器根据该字段返回适配的页面，还有就是这个 accept 值，它会通常告诉服务器它这边能接收哪些类型的数据，像常见的像 html，xml，json，png等等。那还有就是 accept language，就是它会告诉你优先它想显示的语言，像有英文的话就是en-us，还有像中文zh-cn，繁体的话zh-tw对。那除此之外，那这边客户请求的话还会携带 cookie 值，携带客户端本地存储的 Cookie（如会话 ID、用户标识，由服务器通过 Set-Cookie 设置）。那除此之外，嗯，如果说遇到刚刚说的协商缓存，那 http 请求中可能还会携带像 if not modify 或 if not match 的值字段。那当然，如果说有用到需要验证的场景，它通常还会写到一个 authorization 的字段，携带认证信息包括Basic认证或者JWT token。

    **4.11** https是否绝对安全？
    - **证书验证漏洞**：虽然HTTPS通过SSL/TLS协议使用数字证书来验证服务器身份，但存在证书验证机制被绕过的可能。比如攻击者可以利用**中间人攻击，伪造证书**，若客户端没有严格验证证书的有效性，就可能会信任伪造的证书，从而导致通信内容被窃取或篡改。
    - **协议本身漏洞**：SSL/TLS协议在发展过程中也出现过一些安全漏洞。例如，**曾经的心脏滴血漏洞（Heartbleed）**，它允许攻击者从**受影响的服务器内存中读取敏感信息，包括私钥、用户密码等**。即使协议不断更新修复漏洞，但新的漏洞仍可能被发现。
    - **客户端软件问题**：客户端使用的**浏览器、应用程序等软件如果存在安全漏洞**，也会影响HTTPS的安全性。比如某些**旧版本的浏览器可能不支持最新的SSL/TLS协议版本**，或者存在对证书验证的缺陷，这就为攻击者提供了可乘之机。
    - **人为因素**： 用户可能会忽视浏览器的安全提示，比如在**遇到证书错误时，仍然选择继续访问网站**。此外，网站管理员如果配置不当，如使用弱密码保护私钥、未及时更新证书等，也会降低HTTPS的安全性。


5. DNS解析的过程？

    ![alt text](image-6.png)

    - 回答：那通常我们在访问一个网页的时候，这个 DNS 的解析过程通常最开始浏览器会先去查看浏览器本身它是否有这个 DNS 的缓存，那如果浏览器没有 DNS 缓存，那它就会通过这个操作系统去查询自身的操作系统缓存，如果没有会进一步查看 host file，如果host file也没有，那他就会去调用本地的DNS服务器，通常都是你的ISP运营商提供的一个DNS服务器，也是你的设备接入互联网的首个 DNS 查询节点。通常浏览器或者操作系统会向本地服务器请求一个递归查询，它不关心中间经理了多少个DNS服务器，只在乎结果，此时本地 DNS 服务器去查看本地 DNS 服务器中是否会有对应的缓存，那如果没有的话，那此时就是本地的 DNS 服务器就会去发起一个 迭代请求的DNS 请求，会去分别访问像根域名器、顶级域名服务器、权威域名服务器，最后得到响应的ip并返回给浏览器，实现域名到IP的转换。

    **5.1** DNS在传输层用什么协议？
    - DNS在传输层既可能用UDP也可能用TCP。
    - UDP：**大多数 DNS 查询使用 UDP 协议**。对于普通的域名查询，请**求和响应的数据量通常较小**，UDP 协议的特性能够很好地满足这类需求，可以满足**开销小和效率高**的场景。
    - TCP：
        - **区域传输：**：当 **DNS 服务器之间需要进行区域传输（Zone Transfer）时**，通常会使用 TCP 协议，因为区域传输的数据量较大，可能超过 UDP 的数据包大小限制。
        - **响应数据过长**：当 DNS 查询的**响应数据超过512 字节时**，通常会使用 **TCP 协议**。因为 UDP 协议的数据包有大小限制（一般为 512 字节），超过这个限制的数据可能会被截断，而 TCP 协议没有这个限制，可以传输大量的数据。


6. cookie和session是什么？
- 定义：Cookie 和 Session 是用于**管理用户状态和存储信息**的两种技术，常用于Web开发中。
- cookie：Cookie 是**由客户端保存**用户浏览器中的**小块数据**，通常用于保存用户的偏好设置、登录信息和跟踪用户行为等。
- session：Session **是在服务器上保存**的用户状态信息，通常用于在**用户与服务器的交互过程中**保存用户的登录状态和其他信息。
- 回答：首先先明确一点，HTTP 本身它是无状态的协议，所以说在现在 Web 应用当中通常会使用 cookie 和 session 去保存用户状态信息和存储信息，那 cookie 和 session 的区别从这几个角度出发，首先它们的存储位置不一样，cookie 是存在客户端的浏览器当中，那么 session 它是存在服务器当中，那么其次安全性来讲的话，cookie 因为它是保存在客户端的浏览器，并且它每次传输的时候都会附加在这个 HTTP 请求的当中，那么 session 则是保存在服务器当中，所以相对于来说，session 会比 cookie 安全更多，并不太容易被中间人攻击或者泄露，但cookie也有提升安全性的办法，比如cookie的secure和httponly的属性，还有包括samesite的属性像strict，lax和none。那么除此之外，就是他们这个数据量也不一样，cookie 通常是保留一些小块数据，单个 Cookie一般不超过4KB，单个域名下 所有Cookie不超过20-50个，比如就是保留一个 session ID 等等。那 session 这边没有明确大小限制，可以存储用户信息、权限、购物车等复杂数据。那这也是一点，那除此之外，它们的生命周期也不一样，cookie 通常会根据一个expires或者max-age的具体值表明过期时间，而session主要通过超时删除(比如客户30分钟无操作)或者主动删除(客户点击退出登录)两种方式，但是通常cookie和session是搭配使用，cookie保存Session ID，Session 存在服务器，服务器通过session id识别用户状态。那最后一点就是它们的用途也不太一样，cookie 通常用于保存用户偏好设置、跟踪用户行为等，而 session 主要用于保存用户登录状态、权限信息等。


    **6.1** cookie和session的区别？
    - 存储位置
    - 数据量
    - 安全性
    - 生命周期
    - 用途

        ![alt text](image-7.png)

        ![alt text](image-46.png)

    **6.2** cookie提升安全性的属性有哪些？
    - **secure属性**：有了该属性，只有在**HTTPS连接下才会将其包含在请求头中发送给服务器**，这样能有效避免在不安全的HTTP连接中Cookie被中间人截获。
    - **HttpOnly**：此属性限制了Cookie的访问权限。当一个Cookie被设置了HttpOnly属性后，它只能通过 **HTTP协议访问，JavaScript脚本无法读取该Cookie。** 这能有效防止跨站脚本攻击（XSS），因为攻击者无法利用恶意脚本获取到包含敏感信息的Cookie，从而降低了用户信息泄露的风险。
    - **SameSite属性**：
        - Strict：**完全禁止第三方请求携带Cookie**，防止跨站请求伪造（CSRF）攻击。
        - Lax：允许部分第三方请求携带Cookie，例如**从外部网站导航到目标网站的GET请求**，但对于其他类型的请求（如POST）则不允许携带Cookie。
        - None：**允许所有第三方请求携带Cookie，但必须同时设置Secure属性**，确保在HTTPS连接下传输。
    - **Expire和Max-Age**：和http缓存的值类似，但是是定义cookie的：
        - **Expires：**指定了Cookie的**具体过期日期和时间**。当到达这个时间后，浏览器会自动删除该Cookie。
        - **Max - Age：**以秒为单位指定Cookie的有效时长。从Cookie**被创建开始计算，经过指定的秒数后，Cookie就会失效**。通过设置较短的有效期，可以降低Cookie在长时间内被窃取后用于非法操作的可能性。
7. 请解释epoll的原理和作用?
- 定义：epoll 是 Linux 内核提供的一种**I/O 多路复用机制**。
- 作用：高效地同时监听 **成千上万个文件描述符FD** (socket、pipe、文件等) 的可读/可写事件。
- 对比：传统的 select / poll 也能做多路复用，但效率差，每次调用都要把**所有 fd 传给内核**，fd 数量越多，性能越差，单个select只有1024个fd上限；Epoll 没有**最大 fd 数量限制**；内核里维护事件表，**不需要重复传 fd**；支持 **事件驱动（回调机制）**，效率更高。
- 关键系统调用：
    - epoll_create

        ![alt text](image-43.png)

    - epoll_ctl

        ![alt text](image-44.png)

    - epoll_wait

        ![alt text](image-45.png)

- 工作模式：
    - **水平触发(LT)**
    - **边缘触发(ET)**

        ![alt text](image-42.png)

- 回答：epoll是 Linux IO多路复用的一个机制，相对于传统的 select, epoll它可以监听成千上万个文件描述符 FD 的可读可写事件。传统的 select 它也可以支持 IO多路复用，但是它的效率非常低，并且每次都需要将全部文件描述服务上传到内核，然后再进行一次遍历，并且当进程去读这个，嗯，内核的时候还是需要再遍历一次。并且单个 select 它仅支持1,024个文件描述符，但是epoll 是没有任何限制的。那再就是epoll还支持事件驱动，通过epoll wait 这个机制去将嗯，可读可写的事件通知到进程当中，那么同样的它还有两种工作模式，一种是边缘，一种是水平。那么水平的话就是。epoll的默认工作机制。通常就是epoll_wait会监听所有文件描述符是否有可读可写事件，并通知进程去处理这些事件。如果当下进程没有处理完，那么它会在下一次的一个轮次的时候再次通知这些进程剩下的可读可写时间，但是边缘工作模式就不一样，它是只有在文件描述符的状态发生改变的时候才会通知，比如当前可能是一个空闲状态，突然变成一个可读的状态。那么它就会通知到这个进程，但如果进程一次没有处理完，那当下的文件描述符还是处于一个可读的状态，那就不会继续通知，这是他们两者的一个区别。

8. 什么是ARP协议？
- 定义：ARP（Address Resolution Protocol，地址解析协议）是一种用于在**局域网中通过IP地址查找对应的MAC地址的协议**。它在以太网等局域网技术中广泛应用。
- 工作原理：
    - 请求广播： 当一台主机需要将数据包发送到同一局域网中的另一台主机时，它需要知道目标主机的MAC地址。如果主机只知道目标主机的IP地址，它会向**网络广播一个ARP请求，内容包括目标IP地址**。
    - ARP响应： 所有接收该请求的主机都会检查这个请求中的目标IP地址。**如果某台主机的IP地址与请求中的目标IP地址相匹配，它会发送一个ARP响应，回复其MAC地址**。
    - 缓存： 请求主机会接收到ARP响应，获取到目标主机的MAC地址，**并将这个信息缓存起来，以便后续快速访问，避免重复发送ARP请求**。
    - 数据包发送： 获取到MAC地址后，请求主机就可以将数据包发送到目标主机的MAC地址上。
- 安全性：ARP协议本身并没有安全机制，容易受到**ARP欺骗（ARP Spoofing）等攻击**。这种攻击使得攻击者能够将其MAC地址与合法主机的IP地址相关联，从而截获或篡改网络流量。因此，在一些安全要求较高的网络环境中，可能会使用其他安全协议来增强ARP的安全性。

- 回答：ARP 协议，它是一个通过对方的 IP 请求对方的 Mac 地址的这么一个协议，全能就是 address resolution Protocol，那么通过他是在局域网内去进行的，通常他的一个工作模式有三点，第一个是 ARP 请求。那么客户端会通过目标端的 IP 去向这个广播地址去发一个 ARP请求报文，那其中他就会带上自己的这个 IP 和自己的 Mac 地址以及目标端的 IP，和全0的目标端的mac地址，通过二层广播地址发到所有局域网内的主机当中。那第二步就是这些主机会接收这个 ARP 请求，并且对比自己的 IP 地址，如果发现自己的 IP 地址相同，那么他们则会将自己的 Mac 地址填入到这个 ARP 请求当中，并且以单播方式直接回应给这个客户端。但是如果发现 IP 不相同，他们则会丢弃这个 ARP 请求。那么最后一步就是当 ARP 响应回到客户端之后，客户端会解析并且将当中的 Mac 地址存到自己本地的ARP缓存表，那么此时这个客户端得到了 Mac 地址后，就可以开始传输数据了。

9. 常见的网络协议：
- 传输文件：
    - FTP（File Transfer Protocol，文件传输协议）：用于在网络上进行文件的上传和下载。它基于**客户端 - 服务器模式**，允许用户通过命令行或图形界面工具连接到远程服务器，管理和传输文件。例如，**网站管理员通过 FTP 将网站的网页文件、图片等上传到服务器**。
    - TFTP（Trivial File Transfer Protocol，简单文件传输协议）：是一种简化版的文件传输协议，它**不需要用户进行身份验证**，实现起来较为简单，占用资源少。常用于在**网络设备（如路由器、交换机）之间传输配置文件**，或者在无盘工作站启动时从服务器获取引导文件。

- 电子邮件：
    - SMTP（Simple Mail Transfer Protocol，简单邮件传输协议）：主要用于发送电子邮件。当用户在邮件客户端撰写好邮件并点击发送时，**邮件客户端会通过 SMTP 协议将邮件发送到发件人的邮件服务器，然后发件人的邮件服务器再通过 SMTP 协议将邮件转发到收件人的邮件服务器**。
    - POP3（Post Office Protocol - Version 3，邮局协议第 3 版）：用于接收电子邮件。邮件服务器接收到邮件后会存储在邮箱中，**用户的邮件客户端使用 POP3 协议从邮件服务器下载邮件到本地**。下载后，邮件通常会从服务器上删除。
    - IMAP（Internet Message Access Protocol，互联网消息访问协议）：也是用于接收电子邮件的协议，但**与 POP3 不同，IMAP 允许用户在本地客户端对服务器上的邮件进行管理，如分类、标记等操作，而邮件仍然保留在服务器上。**

        ![alt text](image-48.png)

        ![alt text](image-50.png)

- 用于万维网：
    - http（Hypertext Transfer Protocol，超文本传输协议）：是用于传输超文本的协议，是万维网数据通信的基础。它是一种**无状态的协议**，客户端（如浏览器）**向服务器发送请求，服务器返回相应的资源（如 HTML 页面、图片等）**。例如，当我们在浏览器中输入网址并回车，浏览器就会通过 HTTP 协议向对应的服务器请求网页资源。
    - https（Hypertext Transfer Protocol Secure，超文本传输安全协议）：是在 HTTP 的基础上加入了 **SSL/TLS 协议进行加密和身份验证**，保证了数据在传输过程中的安全性和完整性。现在大多数网站都采用 HTTPS 协议，特别是涉及用户隐私信息（如登录、支付等）的网站。

- 用于域名解析：
    - DNS（Domain Name System，域名系统）：将人类可读的域名（如 www.example.com）转换为计算机能够识别的 IP 地址。当我们在浏览器中输入域名时，**浏览器会先向 DNS 服务器发送请求**，获取该域名对应的 IP 地址，然后再通过该 IP 地址与对应的服务器进行通信。

- 用于远程登录：
    - Telnet：允许用户通过网络远程登录到其他计算机上，并在远程计算机上执行命令。不过，**Telnet 协议在传输数据时是明文的**，存在安全风险，现在使用得越来越少。
    - SSH（Secure Shell，安全外壳协议）：同样用于远程登录和执行命令，但它**通过加密和身份验证机制保证了通信的安全性**。SSH 广泛应用于系统管理员远程管理服务器，以及开发人员在不同服务器之间进行代码部署等操作。

    **12.1** 网络层有哪些协议？
    - IP：IP协议是网络层的核心协议，它为互联网上的每台设备分配唯一的IP地址，使得**数据包能够在不同网络之间进行路由和转发**。目前主要有IPv4和IPv6两个版本。IPv4使用32位地址，地址数量有限；IPv6使用128位地址，能够提供几乎无限的地址空间，以满足日益增长的联网设备需求。
    - ARP：**地址解析协议**，用于将**IP地址解析为MAC地址**，以便在局域网中进行数据帧的传输。
    - ICMP：**互联网控制消息协议**，用于在网络设备之间传递控制消息，如错误报告和诊断信息（**例如ping命令**）。
    - RIP：**路由信息协议**，一种动态路由协议，用于在**自治系统内传播路由信息**。
    - OSPF：**开放最短路径优先**，一种链路状态路由协议，广泛用于大型企业网络中。
    - BGP：**边界网关协议**，主要用于互联网的核心路由选择，支持**不同自治系统之间的路由信息交换**。

10. 介绍QUIC协议？
- 定义:QUIC（Quick UDP Internet Connections）是一种基于 UDP 设计的传输层网络协议，由 Google 开发，旨在提供比 TCP 更快、更可靠的网络连接
- 快速建立连接：
    - 减少握手延迟：QUIC 可以在首次连接时通过 0 - RTT 或 1 - RTT 完成握手。0 - RTT **意味着客户端可以在第一次与服务器通信时就发送应用数据**，无需等待握手完成，大大减少了连接建立的时间。
    - 会话恢复：QUIC 会为**每个连接分配一个唯一的连接 ID**，即使客户端的 IP 地址或端口发生变化，只要连接 ID 不变，就可以快速恢复之前的会话，避免重新进行握手。
- 多路复用：
    - 避免队头阻塞：在 TCP 中，同一连接上的多个数据流是按顺序传输的，如果一个数据包丢失，后续的数据包都需要等待该数据包重传，这就是队头阻塞问题。而 QUIC 支持多路复用，不同的数据流可以在同一个连接上独立传输，**一个数据流的丢包不会影响其他数据流的传输，提高了传输效率**。
- 可靠传输：
    - 数据包编号和确认机制：QUIC 为**每个数据包分配一个唯一的编号**，并使用类似 TCP 的确认机制来确保数据包的可靠传输。如果数据包丢失，**接收方会发送 NACK（Negative Acknowledgment）通知发送方重传**。
    - 前向纠错(FEC)：QUIC 还支持前向纠错技术，发送方可以在发送数据的同时发送一些冗余信息，接收方可以利用这些冗余信息在不等待重传的情况下恢复丢失的数据包，进一步提高了传输的可靠性和效率。
- 拥塞控制：QUIC 实现了**多种拥塞控制算法**，并且可以在运行时**动态切换**。这使得 QUIC 能够更好地适应不同的网络环境和应用场景，提高网络利用率。
- 安全性：QUIC 集成了 TLS 1.3 加密协议，所有数据在传输过程中都进行加密，保证了数据的机密性和完整性。与 TCP + TLS 的组合相比，**QUIC 减少了加密握手的延迟，提高了安全性和性能。**

    ![alt text](image-63.png)

11. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？
- **短轮询（Short Polling）**：
    - 客户端定期向服务器发送请求，询问是否有新数据。客户端每隔一定时间（例如每2秒）发送**一个HTTP请求到服务器**，如果有新消息则返回数据，否则返回空。
- **长轮询（Long Polling）**：
    - 客户端发送请求，**一直保持连接**，直到服务器有新数据或请求超时。客户端发送HTTP请求，服务器在有新数据时立即回复客户端，如果没有，**则保持连接，直到有新数据或者超时后才回复**。
- SSE（Server-Sent Events）：一种**单向的服务器推送技术**，服务器可以主动向客户端推送数据。**客户端通过一个特定的HTTP连接向服务器请求数据**，服务器通过这个连接持续发送事件。
- WebSocket：一种全双工的通信协议，允许客户端和服务器之间进行实时的数据交换。
- 回答：短轮巡就是通常就是客户端会定期，比如说2秒发送一个 HTTP 请求到服务器，那服务器如果有新的数据则响应，如果没有就返回空，那么长轮巡通常就是客户端发送HTTP请求，服务器暂时没有新数据就会一直保持连接，直到服务器有新数据或请求超时。那这两个的方式就现在已经被淘汰了，主要短轮询频繁的http请求造成了大量的带宽消耗，并且仍有间隔性实时性差，长轮询容易造成挂起请求会占用大量连接资源，导致高并发时服务器连接数被打满。那通常现在用的更多的是 Websocket，通过一次 HTTP 连握手建立 Websocket 的协议升级。然后后续服务器和客户端就通过 Websocket 进行全双工的通信，后续通信基于单一 TCP 长连接，不再走 HTTP 协议，直接传输 WebSocket 帧。那么 SSE 它是基于HTTP 协议的 “服务器单向推送技术”，仅支持 “服务器→客户端” 单方向通信，无需做协议升级。

12. 传输层，网络层和数据链路层有什么区别？
- **传输层**：
    - 定义：它是在**网络层提供的服务基础上**，主要负责为**应用程序之间提供端到端的通信服务**。
    - 功能：
        - **端到端连接**
        - **可靠传输**
        - **流量控制**
        - **复用和分用**
- **网络层**：
    - 定义：网络层负责将数据包**从源主机传输到目标主机**，它主要处理网络中的**路由选择**和**数据包转发问题**。
    - 功能：
        - **路由选择(控制层面)**：**路由器是网络层的主要设备**，它会根据路由表中的信息，决定**数据**包到各网络目的地的**最佳路径**。
        - **数据包转发(数据层面)**：当数据包到达路由器时，根据路由表中的信息，**选择一个输出接口**，将数据包转发出去。
        - **网络互联**：使得**不同网络中的主机可以相互通信**(局域网和广域网)。
        - **拥塞控制**：当网络出现拥塞时，采取**相应的措施来缓解拥塞**，保证网络的正常运行。

- **数据链路层**：
    - 定义：数据链路层负责将网络层传来的**数据包封装成帧**，并在**相邻节点之间进行可靠的帧传输**。
    - 功能：
        - **差错控制**：通过**差错检测和重传机制**，保证帧在传输过程中的正确性。常用的差错检测方法有**奇偶校验、循环冗余校验（CRC）** 等。
        - **流量控制**：协调**相邻节点之间的数据传输速率**，防止发送方发送数据过快，导致接收方无法及时处理。（采用**停止 - 等待协议**或**滑动窗口协议**来实现流量控制）
        - **介质访问控制**：当多个节点共享**同一传输介质时**，协调各个节点对介质的访问，避免发生冲突。

    
13. 解释什么是CDN？
    - 定义：CDN即内容分发网络（Content Delivery Network），它是一种通过在网络**各处部署节点服务器**，构成的分布式网络系统。CDN的主要目的是将内容（如网页、视频、图片等）缓存到离用户更近的节点上，从而提高内容的访问速度和可靠性。当用户访问网站时，不再直接访问源站，而是从离**用户最近的CDN节点获取所需内容**。